#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <NimBLEDevice.h>
#include <ArduinoJson.h>
#include <time.h>

// =====================================================
// [CONFIG] WiFi / Cloud / BLE parameters
// =====================================================

// Set your own hotspot credentials and cloud API URL
const char* WIFI_SSID = "";
const char* WIFI_PASS = "";
const char* API_URL   = "https://api-production-e339.up.railway.app/data";

static WiFiClientSecure s_client;

// BLE (must match Sensor)
// BLE（必须与 Sensor 端一致）
static NimBLEUUID SVC_UUID("6e400001-b5a3-f393-e0a9-e50e24dcca9e");
static NimBLEUUID CHR_UUID("6e400003-b5a3-f393-e0a9-e50e24dcca9e");
static const char* SENSOR_NAME = "ELEV-SENSOR";

// =====================================================
// [STATE] Runtime state (Gateway-side)
// =====================================================

// Incremental ID (generated by Gateway)
// 递增 ID（网关侧生成）
static uint32_t g_id = 0;

static NimBLEAdvertisedDevice* g_found = nullptr;
static NimBLEClient* g_client = nullptr;
static NimBLERemoteCharacteristic* g_chr = nullptr;

// =====================================================
// [UTILS] BLE raw payload debugging / JSON slicing
// =====================================================

// Dump hex: useful to debug invisible/extra bytes in BLE payload
// 打印十六进制：用于排查 BLE 数据里的不可见/脏字节
static void dumpHex(const uint8_t* p, size_t n) {
  Serial.print("[GW] HEX: ");
  for (size_t i = 0; i < n; i++) {
    if (p[i] < 16) Serial.print('0');
    Serial.print(p[i], HEX);
    Serial.print(' ');
  }
  Serial.println();
}

// Slice JSON object from raw bytes: keep from first '{' to last '}', removing junk bytes
// 从原始字节流里截取第一个 '{' 到最后一个 '}'：去掉头尾脏数据
static String sliceJsonObject(const uint8_t* p, size_t n) {
  int first = -1, last = -1;
  for (size_t i = 0; i < n; i++) if (p[i] == '{') { first = (int)i; break; }
  for (int i = (int)n - 1; i >= 0; i--) if (p[i] == '}') { last = i; break; }
  if (first < 0 || last < 0 || last <= first) return String();

  String out;
  out.reserve((size_t)(last - first + 1));
  for (int i = first; i <= last; i++) out += (char)p[i];
  return out;
}

// =====================================================
// [TIME] NTP sync + ISO8601 timestamp
// =====================================================

// NTP sync (requires WiFi)
// NTP 同步（依赖 WiFi）
static void initTimeNTP() {
  configTime(0, 0, "pool.ntp.org", "time.nist.gov");

  // Wait up to 5s to obtain a valid time
  // 最多等待 5 秒获取有效时间
  unsigned long t0 = millis();
  time_t now;

  while (millis() - t0 < 5000) {
    time(&now);
    if (now > 1700000000) { // Rough check: time synced (> 2023) / 粗略判断：已同步（> 2023）
      Serial.println("[GW] NTP time synced");
      return;
    }
    delay(200);
  }
  Serial.println("[GW] NTP sync timeout (fallback timestamp may be used)");
}

// Generate ISO8601 UTC timestamp: 2026-02-23T14:54:17.322Z
// 生成 ISO8601 UTC 时间戳：2026-02-23T14:54:17.322Z
static void makeIsoTime(char* buf, size_t buflen) {
  time_t now;
  time(&now);

  // If NTP fails, 'now' may be small; fallback to millis()-based placeholder
  // 若 NTP 未同步成功，则使用占位时间戳（1970 + 毫秒）
  if (now < 1700000000) {
    snprintf(buf, buflen, "1970-01-01T00:00:00.%03luZ", (unsigned long)(millis() % 1000));
    return;
  }

  // Convert to UTC time struct
  // 转成 UTC 时间结构体
  struct tm tm_utc;
  gmtime_r(&now, &tm_utc);

  // Compose ISO8601 (seconds + milliseconds)
  // 拼接 ISO8601（秒 + 毫秒）
  char base[32];
  strftime(base, sizeof(base), "%Y-%m-%dT%H:%M:%S", &tm_utc);
  snprintf(buf, buflen, "%s.%03luZ", base, (unsigned long)(millis() % 1000));
}

// =====================================================
// [CLOUD] HTTPS POST to Railway
// =====================================================

// POST JSON to Railway API (HTTPS POST /data)
// 将 JSON 发送到 Railway API（HTTPS POST /data）
bool postJsonToCloud(const String& json) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("[GW] WiFi not connected, skip POST");
    return false;
  }

  // Skip TLS cert validation during bring-up (use CA validation for production)
  // 调试阶段跳过证书校验（生产建议使用 CA 校验）
  s_client.setInsecure();
  s_client.setTimeout(15000);

  HTTPClient http;
  http.setTimeout(15000);

  if (!http.begin(s_client, API_URL)) {
    Serial.println("[GW] http.begin failed");
    return false;
  }

  http.addHeader("Content-Type", "application/json");
  http.addHeader("Accept", "application/json");
  http.addHeader("Connection", "close");

  Serial.print("[GW] POST body: ");
  Serial.println(json);

  int code = http.POST((uint8_t*)json.c_str(), json.length());
  String resp = http.getString();

  Serial.printf("[GW] POST /data code=%d\n", code);
  Serial.print("[GW] resp: ");
  Serial.println(resp);

  http.end();
  return (code >= 200 && code < 300);
}

// =====================================================
// [WIFI] Connect to hotspot
// =====================================================

// Connect WiFi: required for forwarding data to cloud
// 连接 WiFi：用于将网关数据转发到云端
void wifiConnect() {
  WiFi.mode(WIFI_STA);
  WiFi.disconnect(true);
  delay(200);

  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("[GW] WiFi connecting");

  unsigned long t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 20000) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("[GW] WiFi OK, IP=");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("[GW] WiFi connect FAILED");
  }
}

// =====================================================
// [BLE] Scan / Connect / Reset
// =====================================================

// BLE scan callback: find Sensor by name or service UUID
// BLE 扫描回调：按名字或服务 UUID 找到 Sensor
class ScanCallbacks : public NimBLEScanCallbacks {
  void onResult(const NimBLEAdvertisedDevice* adv) {
    if (adv->haveName() && adv->getName() == std::string(SENSOR_NAME)) {
      Serial.print("[GW] Found sensor by name: ");
      Serial.println(adv->getName().c_str());
      g_found = new NimBLEAdvertisedDevice(*adv);
      NimBLEDevice::getScan()->stop();
      return;
    }
    if (adv->isAdvertisingService(SVC_UUID)) {
      Serial.println("[GW] Found sensor by service UUID");
      g_found = new NimBLEAdvertisedDevice(*adv);
      NimBLEDevice::getScan()->stop();
      return;
    }
  }
};
static ScanCallbacks g_scanCb;

// Start scanning for a given number of seconds
// 扫描若干秒
void bleStartScan(uint32_t seconds = 5) {
  Serial.printf("[GW] BLE scanning (%us)...\n", seconds);
  NimBLEScan* scan = NimBLEDevice::getScan();
  scan->setScanCallbacks(&g_scanCb, false);
  scan->setInterval(45);
  scan->setWindow(15);
  scan->setActiveScan(true);
  scan->start(seconds, false);
}

// Connect to Sensor and get target characteristic (for readValue)
// 连接 Sensor 并获取目标 characteristic（用于 readValue）
bool bleConnectAndGetChar() {
  if (!g_found) return false;

  Serial.println("[GW] Connecting to sensor...");
  g_client = NimBLEDevice::createClient();

  if (!g_client->connect(g_found)) {
    Serial.println("[GW] BLE connect FAILED");
    NimBLEDevice::deleteClient(g_client);
    g_client = nullptr;
    delete g_found; g_found = nullptr;
    return false;
  }
  Serial.println("[GW] BLE connected");

  NimBLERemoteService* svc = g_client->getService(SVC_UUID);
  if (!svc) {
    Serial.println("[GW] Service not found");
    g_client->disconnect();
    NimBLEDevice::deleteClient(g_client);
    g_client = nullptr;
    delete g_found; g_found = nullptr;
    return false;
  }

  g_chr = svc->getCharacteristic(CHR_UUID);
  if (!g_chr) {
    Serial.println("[GW] Characteristic not found");
    g_client->disconnect();
    NimBLEDevice::deleteClient(g_client);
    g_client = nullptr;
    delete g_found; g_found = nullptr;
    return false;
  }

  Serial.println("[GW] Ready to readValue()");
  delete g_found; g_found = nullptr;
  return true;
}

// Reset BLE state: disconnect and cleanup
// 重置 BLE 状态：断开并清理对象
void bleReset() {
  if (g_client) {
    if (g_client->isConnected()) g_client->disconnect();
    NimBLEDevice::deleteClient(g_client);
  }
  g_client = nullptr;
  g_chr = nullptr;
  if (g_found) { delete g_found; g_found = nullptr; }
}

// =====================================================
// [PIPELINE] Read -> Clean -> Parse -> Build -> Post
// =====================================================

// Ensure BLE connected: scan and connect if needed
// 确保 BLE 已连接：未连接则扫描并连接
static void gwEnsureBleConnected() {
  if (!g_client || !g_client->isConnected() || !g_chr) {
    if (g_found) bleConnectAndGetChar();
    else bleStartScan(5);
    delay(200);
  }
}

// Read BLE value, dump debug info, and return cleaned JSON string
// 读取 BLE 数据，打印调试信息，并返回清洗后的 JSON 字符串
static bool gwReadSensorJson(String& clean) {
  std::string v;
  try { v = g_chr->readValue(); }
  catch (...) {
    Serial.println("[GW] readValue exception -> reset BLE");
    bleReset();
    delay(500);
    return false;
  }

  if (v.empty()) {
    Serial.println("[GW] BLE read empty");
    delay(1000);
    return false;
  }

  const uint8_t* bytes = (const uint8_t*)v.data();
  size_t n = v.size();

  // Print raw content (replace non-printables with '.')
  // 打印 RAW（不可见字符用 '.' 替代）
  Serial.printf("[GW] RAW(len=%u): ", (unsigned)n);
  for (size_t i = 0; i < n; i++) {
    char c = (char)bytes[i];
    if (c >= 32 && c <= 126) Serial.print(c);
    else Serial.print('.');
  }
  Serial.println();

  // Dump hex for deeper debugging
  // 打印 HEX（进一步排查脏字节）
  dumpHex(bytes, n);

  // Extract/clean JSON object
  // 清洗出 JSON 对象
  clean = sliceJsonObject(bytes, n);
  Serial.print("[GW] CLEAN: ");
  Serial.println(clean);

  if (clean.length() == 0) {
    Serial.println("[GW] CLEAN empty -> skip");
    delay(1000);
    return false;
  }
  return true;
}

// Build Railway JSON payload from cleaned Sensor JSON
// 用 Sensor JSON 生成 Railway 需要的 JSON 结构
static bool gwBuildRailwayPayload(const String& clean, String& jsonOut) {
  // Parse Sensor JSON
  // 解析 Sensor JSON
  StaticJsonDocument<256> doc;
  DeserializationError err = deserializeJson(doc, clean);
  if (err) {
    Serial.print("[GW] JSON parse failed: ");
    Serial.println(err.c_str());
    delay(1000);
    return false;
  }

  // Build payload required by Railway
  // 组装成 Railway 需要的结构
  StaticJsonDocument<384> out;

  out["id"] = (uint32_t)g_id++;

  char tbuf[40];
  makeIsoTime(tbuf, sizeof(tbuf));
  out["t"] = tbuf;

  float p = doc["pressure"].isNull() ? 0.0f : doc["pressure"].as<float>();
  out["pressure"] = (int)lround(p);

  out["accel"] = doc["accel"].isNull() ? 0 : doc["accel"].as<int>();

  out["gyro"] = doc["gyro"].isNull() ? 0.0f : doc["gyro"].as<float>();
  out["mag"]  = doc["mag"].isNull()  ? 0.0f : doc["mag"].as<float>();

  bool movingBool = false;
  if (!doc["moving"].isNull()) {
    if (doc["moving"].is<bool>()) movingBool = doc["moving"].as<bool>();
    else movingBool = (doc["moving"].as<int>() != 0);
  }
  out["moving"] = movingBool;

  out["floor"] = nullptr;

  serializeJson(out, jsonOut);
  return true;
}

// =====================================================
// [MAIN] setup / loop
// =====================================================

void setup() {
  Serial.begin(115200);
  delay(300);
  Serial.println("[GW] boot");

  // 1) WiFi first (cloud needs network)
  // 1) 先连 WiFi（云端转发需要网络）
  wifiConnect();

  // 2) NTP time sync (depends on WiFi)
  // 2) NTP 同步时间（依赖 WiFi）
  initTimeNTP();

  // 3) BLE init (as Central: scan + connect)
  // 3) 初始化 BLE（作为 Central：扫描 + 连接）
  NimBLEDevice::init("ELEV-GW");
  NimBLEDevice::setPower(ESP_PWR_LVL_P9);

  bleStartScan(5);
}

void loop() {
  // Ensure BLE is connected
  // 确保 BLE 已连接
  gwEnsureBleConnected();

  // If still not connected, return early
  // 若仍未连接，直接返回等待下一轮
  if (!g_client || !g_client->isConnected() || !g_chr) return;

  // Read + clean Sensor JSON
  // 读取并清洗 Sensor JSON
  String clean;
  if (!gwReadSensorJson(clean)) return;

  // Build Railway payload
  // 构建 Railway payload
  String jsonOut;
  if (!gwBuildRailwayPayload(clean, jsonOut)) return;

  // Print and post to cloud
  // 打印并上传到云端
  Serial.print("[GW] JSON_OUT: ");
  Serial.println(jsonOut);
  postJsonToCloud(jsonOut);

  delay(1000);
}